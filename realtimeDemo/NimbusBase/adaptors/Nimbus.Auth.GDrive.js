// Generated by CoffeeScript 1.6.3
(function() {
  Nimbus.Auth.GDrive = {
    get_token_from_code: function(code) {
      var data, xhr,
        _this = this;
      xhr = new XMLHttpRequest();
      data = "code=" + code + "&client_id=" + this.key + "&client_secret=" + this.client_secret + "&grant_type=authorization_code&redirect_uri=urn%3Aietf%3Awg%3Aoauth%3A2.0%3Aoob";
      window.data = data;
      xhr.open("POST", "https://accounts.google.com/o/oauth2/token");
      xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
      xhr.onreadystatechange = function(status, response) {
        var e, result;
        if (xhr.readyState === 4) {
          try {
            result = JSON.parse(xhr.response);
            if (result["error"]) {
              return console.log('error');
            } else {
              window.plugins.childBrowser.close();
              localStorage["phonegap_token"] = JSON.stringify(result);
              localStorage["state"] = "Working";
              gapi.auth.setToken(result);
              _this.prepare_gdrive();
              return Nimbus.track.google.registered_user();
            }
          } catch (_error) {
            e = _error;
            return console.log(e);
          }
        }
      };
      xhr.send(data);
      return window.xhr = xhr;
    },
    authenticate_gdrive: function() {
      var auth_url, cb, url;
      log("this should bring up a prompt to initialize into GDrive");
      localStorage["d_key"] = this.key;
      localStorage["secret"] = this.scope;
      localStorage["state"] = "Auth";
      if (document.URL.slice(0, 4) === "file" && (typeof cordova !== "undefined" && cordova !== null)) {
        log("Phonegap google login");
        auth_url = "https://accounts.google.com/o/oauth2/auth?response_type=code&client_id=" + this.key + "&scope=" + encodeURIComponent(this.scope) + "&approval_prompt=auto&redirect_uri=urn:ietf:wg:oauth:2.0:oob";
        window.auth_url = auth_url;
        cb = window.plugins.childBrowser;
        if (cb !== null) {
          cb.onLocationChange = function(loc) {
            return locChanged(loc);
          };
          cb.onClose = function() {
            return onCloseBrowser();
          };
          cb.onOpenExternal = function() {
            return onOpenExternal();
          };
          url = auth_url + "###var sendToApp = function(_key, _val) {var iframe = document.createElement('IFRAME');iframe.setAttribute('src', _key + ':##sendToApp##' + _val);document.documentElement.appendChild(iframe);iframe.parentNode.removeChi(iframe);iframe = null;};var log=function(_mssg){sendToApp('ios-log',_mssg);}; var html = document.getElementById('code').value; log(html);";
          cb.onJSCallback = function(backStr) {
            cb.code = backStr;
            if (backStr && (backStr != null) && backStr !== "(null)") {
              cb.close();
              console.log("will get some toaken");
              return Nimbus.Auth.get_token_from_code(backStr);
            }
          };
          return cb.showWebPage(url);
        }
      } else if (location.protocol === "chrome-extension:") {
        log("chrome extension authorize");
        return this.oauth2_authorize();
      } else {
        return Nimbus.Client.GDrive.request_access_token();
      }
    },
    initialize_gdrive: function() {
      var _this = this;
      log("This part should reflect what initialization needs to be done for GDrive auth");
      Nimbus.gdrive_initialized = true;
      if (Nimbus.loaded) {
        if (location.protocol === "chrome-extension:") {
          return this.oauth2_authorize_second_half();
        } else {
          if (Nimbus.Client.GDrive.is_auth_redirected()) {
            Nimbus.Client.GDrive.handle_auth_redirected();
          }
          console.log("GDrive loaded");
          /* 
            @todo check if token has expired
          */

          if (localStorage['phonegap_token']) {
            gapi.auth.setToken(JSON.parse(localStorage['phonegap_token']));
            return _this.prepare_gdrive();
          }
          return gapi.auth.authorize({
            client_id: this.key,
            scope: this.scope,
            immediate: true,
            authuser: localStorage.authuser || 0
          }, function(data) {
            log("client load handled GDrive");
            log(data);
            if (data !== null) {
              return _this.prepare_gdrive();
            }
          });
        }
      }
    },
    gdrive_authorized: function() {
      return Nimbus.Client.GDrive.check_auth();
    },
    logout_gdrive: function(callback) {
      var k, v, _ref;
      localStorage.clear();
      gapi.auth.setToken(null);
      if (Nimbus.dictModel != null) {
        _ref = Nimbus.dictModel;
        for (k in _ref) {
          v = _ref[k];
          v.records = {};
        }
      }
      if (this.sync_services != null) {
        Nimbus.Auth.setup(this.sync_services);
      }
      if (callback != null) {
        return callback();
      }
    },
    prepare_gdrive: function() {
      window.binary_ready_callback = function() {
        if (Nimbus.Auth.authorized_callback != null) {
          return Nimbus.Auth.authorized_callback();
        }
      };
      return window.startRealtime(function() {
        log("CURRENT SYNCING CALLBACK");
        Nimbus.Auth.app_ready_func();
        Nimbus.track.google.registered_user();
        return setInterval(function() {
          var is_token_expired, is_token_there;
          is_token_there = (gapi.auth.getToken() != null) && (gapi.auth.getToken().access_token == null);
          is_token_expired = gapi.auth.getToken().expires_at - (new Date()).getTime() / 1000 < 60 * 10;
          if (is_token_there || is_token_expired) {
            return gapi.auth.authorize({
              client_id: Nimbus.Auth.key,
              scope: Nimbus.Auth.scope,
              immediate: true,
              authuser: localStorage.authuser || 0
            }, function(data) {
              return console.log('token refreshed');
            });
          }
          return null;
        }, 60000);
      });
      /*
      window.current_syncing = new DelayedOp =>
        log("CURRENT SYNCING CALLBACK")
        Nimbus.Auth.app_ready_func()
      */

    },
    oauth2_authorize: function() {
      var background, params, url;
      background = chrome.extension.getBackgroundPage();
      background.NimbusAuth2 = (function(background_window) {
        var NimbusAuth2;
        NimbusAuth2 = {
          OAUTH2_REDIRECT_URI: 'http://www.google.com/robots.txt',
          getExtensionId: function() {
            return background_window.chrome.i18n.getMessage("@@extension_id");
          },
          isOauth2AuthorizeRedirected: function(base, state) {
            if (base === this.OAUTH2_REDIRECT_URI && state === this.getExtensionId()) {
              return true;
            }
            return false;
          },
          parseParamsString: function(queryString) {
            var m, params, regex;
            params = {};
            regex = /([^&=]+)=([^&]*)/g;
            while (m = regex.exec(queryString)) {
              params[background_window.decodeURIComponent(m[1])] = background_window.decodeURIComponent(m[2]);
            }
            return params;
          },
          parseRedirectedURL: function(url) {
            var base_url, hash, params, _ref;
            _ref = url.split('#'), base_url = _ref[0], hash = _ref[1];
            params = this.parseParamsString(hash);
            return {
              base_url: base_url,
              params: params
            };
          },
          generateRedirectListener: function() {
            var listener,
              _this = this;
            listener = function(tab_id, change_info, tab) {
              var entension_windows, url_obj, w, _i, _len;
              if (change_info.status !== 'loading') {
                return;
              }
              url_obj = _this.parseRedirectedURL(tab.url);
              if (_this.isOauth2AuthorizeRedirected(url_obj.base_url, url_obj.params.state)) {
                background_window.chrome.tabs.onUpdated.removeListener(listener);
                background_window.chrome.tabs.remove(tab_id);
                url_obj['saved_time'] = (new background_window.Date()).getTime();
                background_window.localStorage['_nimbusGDriveAuthObj'] = background_window.JSON.stringify(url_obj);
                if (_this.isPackagedApp()) {
                  background_window.console.log("in packaged app");
                  entension_windows = background_window.chrome.extension.getViews({
                    type: 'tab'
                  });
                  for (_i = 0, _len = entension_windows.length; _i < _len; _i++) {
                    w = entension_windows[_i];
                    if (w.Nimbus.Auth.GDrive.oauth_status_flag === 'ongoing') {
                      w.Nimbus.Auth.GDrive.oauth2_authorize_second_half();
                    }
                  }
                } else if (_this.isBrowserAction()) {
                  background_window.console.log("in browser action");
                }
                return null;
              }
            };
            return listener;
          },
          installRedirectedListener: function() {
            return background_window.chrome.tabs.onUpdated.addListener(this.generateRedirectListener());
          },
          isBrowserAction: function() {
            return 'browser_action' in background_window.chrome.runtime.getManifest();
          },
          isPackagedApp: function() {
            return 'app' in background_window.chrome.runtime.getManifest();
          }
        };
        return NimbusAuth2;
      })(background);
      Nimbus.Auth.GDrive.oauth_status_flag = 'ongoing';
      background.NimbusAuth2.installRedirectedListener();
      url = "https://accounts.google.com/o/oauth2/auth?";
      params = {
        client_id: this.key,
        scope: this.scope,
        redirect_uri: this.OAUTH2_REDIRECT_URI,
        state: this.getExtensionId(),
        response_type: 'token',
        approval_prompt: 'auto'
      };
      url += this.buildParamsString(params);
      return chrome.tabs.create({
        url: url
      });
    },
    oauth2_authorize_second_half: function() {
      var issued_at, save_token, token, url_obj;
      if (localStorage._nimbusGDriveAuthObj != null) {
        url_obj = JSON.parse(localStorage['_nimbusGDriveAuthObj']);
        if ('error' in url_obj) {
          throw new Error("authorization failed with error: " + url_obj.error);
        }
        save_token = url_obj.params;
        issued_at = Math.round(url_obj.saved_time / 1000);
        save_token.client_id = this.key;
        save_token.scope = this.scope;
        save_token.response_type = 'token';
        save_token.issued_at = issued_at.toString();
        save_token.expires_at = (issued_at + parseInt(save_token.expires_in)).toString();
        save_token.state = '';
        delete localStorage['_nimbusGDriveAuthObj'];
        localStorage['_chromeExtensionAuth2Token'] = JSON.stringify(save_token);
      }
      if (localStorage['_chromeExtensionAuth2Token']) {
        token = JSON.parse(localStorage['_chromeExtensionAuth2Token']);
        gapi.auth.setToken(token);
        Nimbus.Auth.GDrive.oauth_status_flag = 'finish';
        return this.prepare_gdrive();
      }
    },
    OAUTH2_REDIRECT_URI: 'http://www.google.com/robots.txt',
    getExtensionId: function() {
      return chrome.i18n.getMessage("@@extension_id");
    },
    buildParamsString: function(obj) {
      var k, params_arr, v;
      params_arr = (function() {
        var _results;
        _results = [];
        for (k in obj) {
          v = obj[k];
          _results.push("" + (encodeURIComponent(k)) + "=" + (encodeURIComponent(v)));
        }
        return _results;
      })();
      return params_arr.join("&");
    },
    getLocalOauth2Token: function(token) {
      if (Nimbus.Auth.GDrive._cacheToken != null) {
        return Nimbus.Auth.GDrive._cacheToken;
      }
      if (localStorage._chromeExtensionAuth2Token != null) {
        token = JSON.parse(localStorage._chromeExtensionAuth2Token);
        Nimbus.Auth.GDrive._cacheToken = token;
        return token;
      } else {
        return null;
      }
    },
    isTokenExpires: function(token) {
      var expires_at, now;
      if ((token != null ? token.expires_at : void 0) != null) {
        expires_at = parseInt(token.expires_at);
        now = (new Date()).getTime();
        if ((expires_at * 1000) > now) {
          return true;
        } else {
          return false;
        }
      }
      return true;
    }
  };

}).call(this);
