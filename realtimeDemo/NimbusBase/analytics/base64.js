// Generated by CoffeeScript 1.6.3
(function() {
  "use strict";
  var atob, b64chars, b64tab, btoa, btou, buffer, cb_btou, cb_decode, cb_encode, cb_utob, decode, encode, encodeURI, fromCharCode, global, noEnum, re_btou, re_utob, utob, version, _decode, _encode;

  global = this;

  if (global.Base64) {
    return;
  }

  version = "2.1.2";

  buffer = void 0;

  if (typeof module !== "undefined" && module.exports) {
    buffer = require("buffer").Buffer;
  }

  b64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  b64tab = function(bin) {
    var i, l, t;
    t = {};
    i = 0;
    l = bin.length;
    while (i < l) {
      t[bin.charAt(i)] = i;
      i++;
    }
    return t;
  };

  b64chars;

  fromCharCode = String.fromCharCode;

  cb_utob = function(c) {
    var cc;
    if (c.length < 2) {
      cc = c.charCodeAt(0);
      if (cc < 0x80) {
        return c;
      } else {
        if (cc < 0x800) {
          return fromCharCode(0xc0 | (cc >>> 6)) + fromCharCode(0x80 | (cc & 0x3f));
        } else {
          return fromCharCode(0xe0 | ((cc >>> 12) & 0x0f)) + fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) + fromCharCode(0x80 | (cc & 0x3f));
        }
      }
    } else {
      cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);
      return fromCharCode(0xf0 | ((cc >>> 18) & 0x07)) + fromCharCode(0x80 | ((cc >>> 12) & 0x3f)) + fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) + fromCharCode(0x80 | (cc & 0x3f));
    }
  };

  re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;

  utob = function(u) {
    return u.replace(re_utob, cb_utob);
  };

  cb_encode = function(ccc) {
    var chars, ord, padlen;
    padlen = [0, 2, 1][ccc.length % 3];
    ord = ccc.charCodeAt(0) << 16 | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8) | (ccc.length > 2 ? ccc.charCodeAt(2) : 0);
    chars = [b64chars.charAt(ord >>> 18), b64chars.charAt((ord >>> 12) & 63), (padlen >= 2 ? "=" : b64chars.charAt((ord >>> 6) & 63)), (padlen >= 1 ? "=" : b64chars.charAt(ord & 63))];
    return chars.join("");
  };

  btoa = global.btoa || function(b) {
    return b.replace(/[\s\S]{1,3}/g, cb_encode);
  };

  _encode = (buffer ? function(u) {
    return (new buffer(u)).toString("base64");
  } : function(u) {
    return btoa(utob(u));
  });

  encode = function(u, urisafe) {
    if (!urisafe) {
      return _encode(u);
    } else {
      return _encode(u).replace(/[+\/]/g, function(m0) {
        if (m0 === "+") {
          return "-";
        } else {
          return "_";
        }
      }).replace(RegExp("=", "g"), "");
    }
  };

  encodeURI = function(u) {
    return encode(u, true);
  };

  re_btou = re_btou = new RegExp(['[\xC0-\xDF][\x80-\xBF]', '[\xE0-\xEF][\x80-\xBF]{2}', '[\xF0-\xF7][\x80-\xBF]{3}'].join('|'), 'g');

  cb_btou = function(cccc) {
    var cp, offset;
    switch (cccc.length) {
      case 4:
        cp = ((0x07 & cccc.charCodeAt(0)) << 18) | ((0x3f & cccc.charCodeAt(1)) << 12) | ((0x3f & cccc.charCodeAt(2)) << 6) | (0x3f & cccc.charCodeAt(3));
        offset = cp - 0x10000;
        return fromCharCode((offset >>> 10) + 0xD800) + fromCharCode((offset & 0x3FF) + 0xDC00);
      case 3:
        return fromCharCode(((0x0f & cccc.charCodeAt(0)) << 12) | ((0x3f & cccc.charCodeAt(1)) << 6) | (0x3f & cccc.charCodeAt(2)));
      default:
        return fromCharCode(((0x1f & cccc.charCodeAt(0)) << 6) | (0x3f & cccc.charCodeAt(1)));
    }
  };

  btou = function(b) {
    return b.replace(re_btou, cb_btou);
  };

  cb_decode = function(cccc) {
    var chars, len, n, padlen;
    len = cccc.length;
    padlen = len % 4;
    n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0);
    chars = [fromCharCode(n >>> 16), fromCharCode((n >>> 8) & 0xff), fromCharCode(n & 0xff)];
    chars.length -= [0, 0, 2, 1][padlen];
    return chars.join("");
  };

  atob = global.atob || function(a) {
    return a.replace(/[\s\S]{1,4}/g, cb_decode);
  };

  _decode = (buffer ? function(a) {
    return (new buffer(a, "base64")).toString();
  } : function(a) {
    return btou(atob(a));
  });

  decode = function(a) {
    return _decode(a.replace(/[-_]/g, function(m0) {
      if (m0 === "-") {
        return "+";
      } else {
        return "/";
      }
    }).replace(/[^A-Za-z0-9\+\/]/g, ""));
  };

  global.Base64 = {
    VERSION: version,
    atob: atob,
    btoa: btoa,
    fromBase64: decode,
    toBase64: encode,
    utob: utob,
    encode: encode,
    encodeURI: encodeURI,
    btou: btou,
    decode: decode
  };

  if (typeof Object.defineProperty === "function") {
    noEnum = function(v) {
      return {
        value: v,
        enumerable: false,
        writable: true,
        configurable: true
      };
    };
    global.Base64.extendString = function() {
      Object.defineProperty(String.prototype, "fromBase64", noEnum(function() {
        return decode(this);
      }));
      Object.defineProperty(String.prototype, "toBase64", noEnum(function(urisafe) {
        return encode(this, urisafe);
      }));
      return Object.defineProperty(String.prototype, "toBase64URI", noEnum(function() {
        return encode(this, true);
      }));
    };
  }

}).call(this);
