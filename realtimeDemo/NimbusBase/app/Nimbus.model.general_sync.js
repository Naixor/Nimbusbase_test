// Generated by CoffeeScript 1.6.3
(function() {
  window.one_time_sync = false;

  window.keys = function(item) {
    var key, keys, value;
    keys = [];
    for (key in item) {
      value = item[key];
      keys.push(key);
    }
    return keys;
  };

  Nimbus.Model.general_sync = {
    cloudcache: {},
    create_object_dictionary: function() {
      var dict, obj, _i, _len, _ref;
      dict = {};
      log("object:", this);
      _ref = this.all();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        obj = _ref[_i];
        dict[obj.id] = obj;
      }
      return dict;
    },
    sync_model_base_algo: function() {
      var cloud, cloud_set, cloud_time, d_array, deleted_set, dlist, eq, id, local, local_item, local_set, local_time, utc, utl, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
      if (!navigator.onLine || this.is_cloud_available === false) {
        return;
      }
      log("#ONE TIME SYNC ALGO RUNNING", this.name);
      window.one_time_sync = true;
      window.currently_syncing = true;
      local = this.create_object_dictionary();
      cloud = this.cloudcache;
      local_set = new Set(keys(local));
      cloud_set = new Set(keys(cloud));
      log("local_set", local_set);
      log("cloud_set", cloud_set);
      d_array = [];
      _ref = this.DeletionStorage.all();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        dlist = _ref[_i];
        this.delete_from_cloud(dlist.id);
        d_array.push(dlist.id);
        dlist.destroy();
      }
      deleted_set = new Set(d_array);
      log("deleted set", deleted_set);
      log("#the set of ids that are there locally but not there on the cloud", local_set.difference(cloud_set)._set);
      _ref1 = (local_set.difference(cloud_set)._set);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        id = _ref1[_j];
        local_item = local[id];
        if ((local_item["synced"] != null) && local_item.synced) {
          log("id for deletion", id);
          local[id].destroy();
        } else {
          this.add_to_cloud(local_item);
        }
      }
      log("#the set of ids that are there on the cloud but not there locally minus deletions", cloud_set.difference(local_set).difference(deleted_set)._set);
      _ref2 = (cloud_set.difference(local_set).difference(deleted_set)._set);
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        id = _ref2[_k];
        this.add_from_cloud(id);
      }
      log("#the set of ids that are there in the cloud and locally", cloud_set.intersection(local_set)._set);
      utc = [];
      utl = [];
      eq = [];
      _ref3 = (cloud_set.intersection(local_set)._set);
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        id = _ref3[_l];
        local_time = new Date(local[id].time);
        cloud_time = new Date(cloud[id].time);
        log("local_time", local_time.toString());
        log("cloud_time", cloud_time.toString());
        if (local_time - cloud_time === 0) {
          log("equal time stamp do nothin", cloud[id].title);
          eq.push(id);
        } else if (local_time - cloud_time > 0) {
          this.update_to_cloud(local[id]);
          utc.push(id);
        } else {
          this.update_to_local(local[id]);
          utl.push(id);
        }
      }
      window.currently_syncing = false;
      window.one_time_sync = false;
      log("updated to cloud", utc.length, utc);
      log("updated to local", utl.length, utl);
      return log("equal timestamp", eq.length, eq);
    },
    real_time_sync: function(record, method, e) {
      var d, syncable;
      log("method", method);
      log("record", record);
      this.saveLocal(record, method);
      if (window.currently_syncing) {
        return true;
      } else {
        if (method === "update") {
          this.records[record.id].time = new Date().toString();
        }
      }
      syncable = navigator.onLine && (localStorage["state"] === "Working" || Nimbus.Client.GDrive.check_auth());
      if (!syncable) {
        console.log("syncing is not setup correctly or the instance is not online");
        return true;
      }
      switch (method) {
        case "destroy":
          if (record.synced) {
            if (syncable) {
              log("deletion in cloud");
              return this.delete_from_cloud(record.id);
            } else {
              d = Deletion.init({
                id: record.id
              });
              return d.save();
            }
          }
          break;
        case "create":
          return this.add_to_cloud(record, function() {});
        case "update":
          return this.update_to_cloud(record, function() {});
        case "read":
          return this.update_to_local(record, function() {});
        default:
          return log("REAL TIME SYNCING FAILED, THIS METHOD NOT IMPLEMENTED");
      }
    },
    delta_update: function() {
      var change;
      return change = this.get_delta;
    }
  };

}).call(this);
