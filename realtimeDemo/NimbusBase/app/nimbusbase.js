// Generated by CoffeeScript 1.6.3
(function() {
  (function() {
    var $, Auth, Binary, Class, Client, DB, Events, Model, Nimbus, Share, isArray, makeArray, moduleKeywords;
    if (window.Nimbus == null) {
      Nimbus = winodw.Nimbus = {};
    }
    Nimbus = window.Nimbus;
    Nimbus.version = "0.0.1";
    $ = Nimbus.$ = this.jQuery || this.Zepto || function() {
      return arguments[0];
    };
    Nimbus.dictModel = {};
    makeArray = function(args) {
      return Array.prototype.slice.call(args, 0);
    };
    isArray = function(value) {
      return Object.prototype.toString.call(value) === "[object Array]";
    };
    if (typeof Array.prototype.indexOf === "undefined") {
      Array.prototype.indexOf = function(value) {
        var i;
        i = 0;
        while (i < this.length) {
          if (this[i] === value) {
            return i;
          }
          i++;
        }
        return -1;
      };
    }
    Events = {
      bind: function(ev, callback) {
        var calls, evs, i;
        evs = ev.split(" ");
        calls = this._callbacks || (this._callbacks = {});
        i = 0;
        while (i < evs.length) {
          (this._callbacks[evs[i]] || (this._callbacks[evs[i]] = [])).push(callback);
          i++;
        }
        return this;
      },
      trigger: function() {
        var args, calls, ev, i, l, list;
        args = makeArray(arguments);
        ev = args.shift();
        if (!(calls = this._callbacks)) {
          return false;
        }
        if (!(list = this._callbacks[ev])) {
          return false;
        }
        i = 0;
        l = list.length;
        while (i < l) {
          if (list[i].apply(this, args) === false) {
            return false;
          }
          i++;
        }
        return true;
      },
      unbind: function(ev, callback) {
        var calls, i, l, list;
        if (!ev) {
          this._callbacks = {};
          return this;
        }
        if (!(calls = this._callbacks)) {
          return this;
        }
        if (!(list = calls[ev])) {
          return this;
        }
        if (!callback) {
          delete this._callbacks[ev];
          return this;
        }
        i = 0;
        l = list.length;
        while (i < l) {
          if (callback === list[i]) {
            list = list.slice();
            list.splice(i, 1);
            calls[ev] = list;
            break;
          }
          i++;
        }
        return this;
      }
    };
    if (typeof Object.create !== "function") {
      Object.create = function(o) {
        var F;
        F = function() {};
        F.prototype = o;
        return new F();
      };
    }
    moduleKeywords = ["included", "extended"];
    Class = {
      inherited: function() {},
      created: function() {},
      prototype: {
        initialize: function() {},
        init: function() {}
      },
      create: function(include, extend) {
        var object;
        object = Object.create(this);
        object.parent = this;
        object.prototype = object.fn = Object.create(this.prototype);
        if (include) {
          object.include(include);
        }
        if (extend) {
          object.extend(extend);
        }
        object.created();
        this.inherited(object);
        return object;
      },
      init: function() {
        var instance;
        instance = Object.create(this.prototype);
        instance.parent = this;
        instance.initialize.apply(instance, arguments);
        instance.init.apply(instance, arguments);
        return instance;
      },
      proxy: function(func) {
        var thisObject;
        thisObject = this;
        return function() {
          return func.apply(thisObject, arguments);
        };
      },
      proxyAll: function() {
        var functions, i, _results;
        functions = makeArray(arguments);
        i = 0;
        _results = [];
        while (i < functions.length) {
          this[functions[i]] = this.proxy(this[functions[i]]);
          _results.push(i++);
        }
        return _results;
      },
      include: function(obj) {
        var included, key;
        for (key in obj) {
          if (moduleKeywords.indexOf(key) === -1) {
            this.fn[key] = obj[key];
          }
        }
        included = obj.included;
        if (included) {
          included.apply(this);
        }
        return this;
      },
      extend: function(obj) {
        var extended, key;
        for (key in obj) {
          if (moduleKeywords.indexOf(key) === -1) {
            this[key] = obj[key];
          }
        }
        extended = obj.extended;
        if (extended) {
          extended.apply(this);
        }
        return this;
      }
    };
    Class.prototype.proxy = Class.proxy;
    Class.prototype.proxyAll = Class.proxyAll;
    Class.inst = Class.init;
    Class.sub = Class.create;
    Nimbus.guid = function() {
      var id, verified, verify_guide;
      verify_guide = function(g_id) {
        var x, y, _ref;
        _ref = Nimbus.dictModel;
        for (x in _ref) {
          y = _ref[x];
          if (y.exists(g_id)) {
            return false;
          }
        }
        return true;
      };
      verified = false;
      while (!verified) {
        id = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
          var r, v;
          r = Math.random() * 16 | 0;
          v = (c === "x" ? r : r & 0x3 | 0x8);
          return v.toString(16);
        }).toUpperCase();
        verified = verify_guide(id);
      }
      return id;
    };
    Auth = Nimbus.Auth = Class.create();
    Auth.extend({
      reinitialize: function() {
        var cloud, service, sync_service;
        log("reintialize called");
        if (localStorage["last_sync_object"] != null) {
          log("the service exists", localStorage["service"]);
          sync_service = JSON.parse(localStorage["last_sync_object"]);
          if (Nimbus.Auth.sync_services == null) {
            Nimbus.Auth.sync_services = {};
            Nimbus.Auth.sync_services.synchronous = sync_service.synchronous;
          } else {
            service = Nimbus.Auth.sync_services[sync_service.service];
            if (service.app_id !== sync_service.app_id) {
              cloud = sync_service.service;
              sync_service = service;
              sync_service.service = cloud;
              localStorage.clear();
            }
          }
          this.setup(sync_service);
          return this.initialize();
        }
      },
      setup: function(sync_service) {
        var item, key, service, value;
        if (typeof sync_service === "string") {
          console.log("Current sync service", sync_service);
          sync_service = JSON.parse(Base64.decode(sync_service));
        }
        if (!this.app_name) {
          this.app_name = sync_service.app_name;
        }
        if (!this.app_name) {
          for (item in sync_service) {
            if (sync_service[item].app_name) {
              this.app_name = sync_service[item].app_name;
              if (this.app_name) {
                break;
              }
            }
          }
        }
        if (sync_service.service != null) {
          log("setup called on a service", sync_service.service);
          log("setup object", sync_service);
          for (key in sync_service) {
            value = sync_service[key];
            this[key] = value;
          }
          if ((Nimbus.Auth.sync_services != null) && (Nimbus.Auth.sync_services.synchronous != null)) {
            sync_service.synchronous = Nimbus.Auth.sync_services.synchronous;
          } else {
            sync_service.synchronous = true;
          }
          sync_service.app_name = this.app_name;
          localStorage["last_sync_object"] = JSON.stringify(sync_service);
          switch (this.service) {
            case "Dropbox":
              this.extend(Nimbus.Auth.Dropbox_auth);
              this.authorize = this.proxy(this.authenticate_dropbox);
              this.initialize = this.proxy(this.initialize_dropbox);
              this.authorized = this.proxy(this.dropbox_authorized);
              this.logout = function() {
                this.proxy(this.logout_dropbox);
                this.clear_storage();
              };
              Nimbus.Binary.setup(this.service);
              return log("service is dropbox");
            case "GDrive":
              this.extend(Nimbus.Auth.GDrive);
              this.authorize = this.proxy(this.authenticate_gdrive);
              this.initialize = this.proxy(this.initialize_gdrive);
              this.authorized = this.proxy(this.gdrive_authorized);
              this.logout = function() {
                this.proxy(this.logout_gdrive);
                this.clear_storage();
              };
              Nimbus.Binary.setup(this.service);
              log("service is GDrive");
              return Nimbus.Share.setup(this.service);
            case "Realtime":
              return startRealtime(key, app_name);
            default:
              return log("Invalid service name");
          }
        } else {
          log("new method for setup, the service is there");
          this.sync_services = sync_service;
          this.models = {};
          if (localStorage["service"] != null) {
            if (localStorage["service"] === "GDrive") {
              service = this.sync_services["GDrive"];
              service["service"] = "GDrive";
              this.setup(service);
            } else {
              service = this.sync_services["Dropbox"];
              service["service"] = "Dropbox";
              this.setup(service);
            }
          } else {
            this.extend(Nimbus.Auth.Multi);
            this.authorize = this.proxy(this.authenticate_service);
            this.initialize = this.proxy(this.initialize_service);
          }
        }
      },
      clear_storage: function() {
        log('Will clear localStorage or indexedDB');
        localStorage.clear();
        PouchDB.destroy(this.app_name);
      },
      authorized: function() {
        return log("authorized not yet setup");
      },
      state: function() {
        return localStorage["state"];
      },
      authorize: function() {
        return log("authorize not yet setup");
      },
      initialize: function() {
        return log("initialize not setup");
      },
      authorized_callback: function() {
        return log("authorized callback undefined");
      },
      app_ready_func: function() {
        log("app_ready");
        return this.app_ready = true;
      },
      set_app_ready: function(callback) {
        var cb;
        log("set app ready");
        if ((this.app_ready != null) && this.app_ready) {
          if (this.service === 'GDrive') {
            return window.folder_initialize(callback);
          } else {
            return callback();
          }
        } else {
          cb = function() {
            if (this.service === 'GDrive') {
              return window.folder_initialize(callback);
            } else {
              return callback();
            }
          };
          return this.app_ready_func = cb;
        }
      },
      logout: function() {
        return log("logout not implemented");
      }
    });
    Client = Nimbus.Client = Class.create();
    Share = Nimbus.Share = Class.create();
    Share.extend({
      setup: function(sync_service) {
        switch (sync_service) {
          case "GDrive":
            log("share api with GDrive");
            this.extend(Nimbus.Client.GDrive);
            this.get_users = this.proxy(this.get_shared_users);
            this.add_user = this.proxy(this.add_share_user);
            this.remove_user = this.proxy(this.remove_share_user);
            this.get_me = this.proxy(this.get_current_user);
            this.get_spaces = this.proxy(this.get_app_folders);
            this.switch_spaces = this.proxy(this.switch_to_app_folder);
            return this.switch_file_real = this.proxy(this.switch_to_app_file_real);
          default:
            return log("share not supported with this service");
        }
      },
      get_users: function() {
        return log("users not implemented");
      },
      add_user: function(email) {
        return log("add a user");
      },
      remove_user: function(id) {
        return log("removed user");
      },
      get_me: function() {
        return log("get currently logged user");
      },
      get_spaces: function() {
        return log("get current spaces");
      },
      switch_spaces: function(id) {
        return log("switch space");
      }
    });
    Binary = Nimbus.Binary = Class.create();
    Binary.extend({
      setup: function(sync_service) {
        log("binary setup called");
        switch (sync_service) {
          case "Dropbox":
            this.extend(Nimbus.Client.Dropbox.Binary);
            Nimbus.Client.Dropbox.Binary.binary_setup();
            return log("service is dropbox");
          case "GDrive":
            this.extend(Nimbus.Client.GDrive.Binary);
            Nimbus.Client.GDrive.Binary.binary_setup();
            return log("service is GDrive");
          case "Realtime":
            return log("service is  Realtime");
          default:
            return log("Invalid service name");
        }
      },
      upload_blob: function(blob, name, callback) {
        return log("upload blob");
      },
      upload_file: function(file, callback) {
        return log("upload blob");
      },
      read_file: function(binary, callback) {
        return log("read file");
      },
      share_link: function(binary, callback) {
        return log("share link");
      },
      direct_link: function(binary, callback) {
        return log("direct link");
      },
      delete_file: function(binary) {
        return log("delete file");
      }
    });
    DB = Nimbus.DB = Class.create();
    DB.extend(Events);
    DB.extend({
      setup_db: function(type) {
        log("setup db");
        switch (type) {
          case "localStorage":
            return Storage.prototype.setItem = function(key, value) {
              if (this === window.localStorage) {
                return log("local storage called");
              } else {
                return _setItem.apply(this, arguments);
              }
            };
        }
      }
    });
    Model = Nimbus.Model = Class.create();
    Model.extend(Events);
    Model.extend({
      loaded: false,
      check_loaded: function() {
        if (this.loaded) {
          return true;
        } else {
          console.log("The model is not loaded yet! Wait for the model to be done with setup.");
          return false;
        }
      },
      service_setup: function(model) {
        var atts;
        log("service setup model", model);
        atts = model.attributes;
        switch (Nimbus.Auth.service) {
          case "Dropbox":
            log("extend as Dropbox");
            model.extend(Nimbus.Model.general_sync);
            model.extend(Nimbus.Model.Dropbox);
            atts.push("synced");
            atts.push("time");
            model.attributes = atts;
            break;
          case "GDrive":
            log("extend as GDrive");
            model.extend(Nimbus.Model.general_sync);
            model.extend(Nimbus.Model.Realtime);
            atts.push("gid");
            atts.push("synced");
            atts.push("time");
            atts.push("type");
            model.attributes = atts;
            break;
          default:
            log("Invalid service name");
        }
        return model;
      },
      setup: function(name, atts, callback) {
        var Deletion, model,
          _this = this;
        log("model setup");
        model = Model.sub();
        if (name) {
          model.name = name;
        }
        if (atts) {
          model.attributes = atts;
        }
        if ((Nimbus.Auth.sync_services.synchronous != null) && Nimbus.Auth.sync_services.synchronous) {
          model.extend(Nimbus.Model.LocalSync);
        } else {
          model.extend(Nimbus.Model.Local);
        }
        Nimbus.dictModel[name] = model;
        if ((Nimbus.Auth.service != null) || (Nimbus.Auth.sync_services != null) || name === "binary" || name === "binary_Deletion") {
          log("model 1", model);
          if (name.indexOf("_Deletion") < 0) {
            model = this.service_setup(model);
          }
        } else {
          log("name:", name);
          log("Please setup Nimbus.Auth first before creating models");
        }
        if (name.indexOf("_Deletion") < 0) {
          Deletion = Nimbus.Model.setup(name + "_" + "Deletion", ["deletion_id", "listid"]);
          Deletion.extend(Nimbus.Model.Local);
          Deletion.fetch();
          model.DeletionStorage = Deletion;
        }
        log(model);
        if (callback != null) {
          model.fetch(function() {
            _this.loaded = true;
            return callback();
          });
        } else {
          model.fetch(function() {
            return _this.loaded = true;
          });
        }
        if (name.indexOf("_Deletion") < 0) {
          Nimbus.dictModel[name] = model;
        } else {
          delete Nimbus.dictModel[name];
        }
        return model;
      },
      created: function(sub) {
        this.records = {};
        return this.attributes = (this.attributes ? makeArray(this.attributes) : []);
      },
      find: function(id) {
        var record;
        record = this.records[id];
        if (!record) {
          throw "Unknown record";
        }
        return record.clone();
      },
      exists: function(id) {
        var e;
        try {
          return this.find(id);
        } catch (_error) {
          e = _error;
          return false;
        }
      },
      refresh: function(values) {
        var i, il, record;
        values = this.fromJSON(values);
        this.records = {};
        i = 0;
        il = values.length;
        while (i < il) {
          record = values[i];
          record.newRecord = false;
          this.records[record.id] = record;
          i++;
        }
        this.trigger("refresh");
        return this;
      },
      select: function(callback) {
        var key, result;
        result = [];
        for (key in this.records) {
          if (callback(this.records[key])) {
            result.push(this.records[key]);
          }
        }
        return this.cloneArray(result);
      },
      findByAttribute: function(name, value) {
        var key;
        for (key in this.records) {
          if (this.records[key][name] === value) {
            return this.records[key].clone();
          }
        }
      },
      findAllByAttribute: function(name, value) {
        return this.select(function(item) {
          return item[name] === value;
        });
      },
      each: function(callback) {
        var key, _results;
        _results = [];
        for (key in this.records) {
          _results.push(callback(this.records[key]));
        }
        return _results;
      },
      all: function() {
        return this.cloneArray(this.recordsValues());
      },
      first: function() {
        var record;
        record = this.recordsValues()[0];
        return record && record.clone();
      },
      last: function() {
        var record, values;
        values = this.recordsValues();
        record = values[values.length - 1];
        return record && record.clone();
      },
      count: function() {
        return this.recordsValues().length;
      },
      deleteAll: function() {
        var key, _results;
        _results = [];
        for (key in this.records) {
          _results.push(delete this.records[key]);
        }
        return _results;
      },
      destroyAll: function() {
        var key, _results;
        _results = [];
        for (key in this.records) {
          _results.push(this.records[key].destroy());
        }
        return _results;
      },
      update: function(id, atts) {
        return this.find(id).updateAttributes(atts);
      },
      create: function(atts) {
        var record;
        record = this.init(atts);
        return record.save();
      },
      destroy: function(id) {
        return this.find(id).destroy();
      },
      sync: function(callback) {
        return this.bind("change", callback);
      },
      fetch: function(callbackOrParams) {
        if (!this.loaded && (callbackOrParams != null)) {
          this.loadLocal(callbackOrParams);
        }
        if (typeof callbackOrParams === "function") {
          return this.bind("fetch", callbackOrParams);
        } else {
          return this.trigger.apply(this, ["fetch"].concat(makeArray(arguments)));
        }
      },
      toJSON: function() {
        return this.recordsValues();
      },
      fromJSON: function(objects) {
        var i, results;
        if (!objects) {
          return;
        }
        if (typeof objects === "string") {
          objects = JSON.parse(objects);
        }
        if (isArray(objects)) {
          results = [];
          i = 0;
          while (i < objects.length) {
            results.push(this.init(objects[i]));
            i++;
          }
          return results;
        } else {
          return this.init(objects);
        }
      },
      recordsValues: function() {
        var key, result;
        result = [];
        for (key in this.records) {
          result.push(this.records[key]);
        }
        return result;
      },
      cloneArray: function(array) {
        var i, result;
        result = [];
        i = 0;
        while (i < array.length) {
          result.push(array[i].clone());
          i++;
        }
        return result;
      }
    });
    return Model.include({
      model: true,
      newRecord: true,
      init: function(atts) {
        var parent_type;
        if (atts) {
          this.load(atts);
        }
        parent_type = this.parent.name;
        this.parent = function() {
          return Nimbus.dictModel[parent_type];
        };
        return this.trigger("init", this);
      },
      isNew: function() {
        return this.newRecord;
      },
      isValid: function() {
        return !this.validate();
      },
      validate: function() {},
      load: function(atts) {
        var name, _results;
        _results = [];
        for (name in atts) {
          _results.push(this[name] = atts[name]);
        }
        return _results;
      },
      attributes: function() {
        var attr, i, result;
        result = {};
        i = 0;
        while (i < this.parent().attributes.length) {
          attr = this.parent().attributes[i];
          result[attr] = this[attr];
          i++;
        }
        result.id = this.id;
        return result;
      },
      eql: function(rec) {
        return rec && rec.id === this.id && rec.parent() === this.parent();
      },
      save: function() {
        var error;
        error = this.validate();
        if (error) {
          this.trigger("error", this, error);
          return false;
        }
        this.trigger("beforeSave", this);
        if (this.newRecord) {
          this.create();
        } else {
          this.update();
        }
        this.trigger("save", this);
        return this;
      },
      updateAttribute: function(name, value) {
        this[name] = value;
        return this.save();
      },
      updateAttributes: function(atts) {
        this.load(atts);
        return this.save();
      },
      destroy: function() {
        this.trigger("beforeDestroy", this);
        delete this.parent().records[this.id];
        this.destroyed = true;
        this.trigger("destroy", this);
        return this.trigger("change", this, "destroy");
      },
      dup: function() {
        var result;
        result = this.parent().init(this.attributes());
        result.newRecord = this.newRecord;
        return result;
      },
      clone: function() {
        return Object.create(this);
      },
      reload: function() {
        var original;
        if (this.newRecord) {
          return this;
        }
        original = this.parent().find(this.id);
        this.load(original.attributes());
        return original;
      },
      toJSON: function() {
        return this.attributes();
      },
      exists: function() {
        return this.id && this.id in this.parent().records;
      },
      update: function() {
        var clone, records;
        this.trigger("beforeUpdate", this);
        records = this.parent().records;
        records[this.id].load(this.attributes());
        clone = records[this.id].clone();
        this.trigger("update", clone);
        return this.trigger("change", clone, "update");
      },
      create: function() {
        var clone, records;
        this.trigger("beforeCreate", this);
        if (!this.id) {
          this.id = Nimbus.guid();
        }
        this.newRecord = false;
        records = this.parent().records;
        records[this.id] = this.dup();
        clone = records[this.id].clone();
        this.trigger("create", clone);
        return this.trigger("change", clone, "create");
      },
      bind: function(events, callback) {
        return this.parent().bind(events, this.proxy(function(record) {
          if (record && this.eql(record)) {
            return callback.apply(this, arguments);
          }
        }));
      },
      trigger: function() {
        var e;
        try {
          return this.parent().trigger.apply(this.parent(), arguments);
        } catch (_error) {
          e = _error;
          return log(e);
        }
      }
    });
  })();

}).call(this);
