// Generated by CoffeeScript 1.7.1
(function() {
  var REALTIME_MIMETYPE, handleErrors;

  REALTIME_MIMETYPE = 'application/vnd.google-apps.drive-sdk';

  Nimbus.Model.Realtime = {
    cloudcache: {},
    toCloudStructure: function(object) {
      log("local to cloud structure");
      object["type"] = this.name;
      return JSON.stringify(object);
    },
    fromCloudStructure: function(value) {
      log("changes cloud to local data in the form a dictionary");
      return JSON.parse(value);
    },
    diff_objects: function(previous, current) {
      var diff, f, v;
      diff = {};
      for (f in previous) {
        v = previous[f];
        if (current[f] !== previous[f]) {
          diff[f] = [current[f], previous[f]];
        }
      }
      if ((previous["parent_id"] != null) !== (current["parent_id"] != null)) {
        diff["parent_id"] = ["one of them is null"];
      }
      return diff;
    },
    add_to_cloud: function(object, callback) {
      var content;
      log("add to cloud", object);
      window.currently_syncing = true;
      object.time = new Date().toString();
      object.type = this.name;
      object.synced = true;
      object.save();
      window.currently_syncing = false;
      content = this.toCloudStructure(object);
      return window.todo.set(object.id, content);
    },
    delete_from_cloud: function(object_id, callback) {
      log("delete from cloud", object_id, window.todo.has(object_id));
      if (window.todo.has(object_id)) {
        return window.todo["delete"](object_id);
      }
    },
    update_to_cloud: function(object, callback) {
      var content;
      log("updated to cloud", object.id);
      content = this.toCloudStructure(object);
      return window.todo.set(object.id, content);
    },
    add_from_cloud: function(object_id, callback) {
      var converted, data, x;
      log("add from cloud GDrive", object_id);
      data = window.todo.get(object_id);
      window.currently_syncing = true;
      converted = this.fromCloudStructure(data);
      x = this.init(converted);
      x.synced = true;
      x.save();
      return window.currently_syncing = false;
    },
    update_to_local: function(object, callback) {
      var converted, data, x;
      log("update to local", object);
      data = window.todo.get(object.id);
      window.currently_syncing = true;
      converted = this.fromCloudStructure(data);
      x = this.init(converted);
      x.synced = true;
      x.save();
      return window.currently_syncing = false;
    },
    sync_all: function(cb) {
      log("syncs all the data, normally happens at the start of a program or coming back from offline");
      this.load_all_from_cloud();
      this.sync_model_base_algo();
      window.current_syncing = new DelayedOp((function(_this) {
        return function() {
          log("call back sync called");
          window.current_syncing = new DelayedOp(function() {
            window.current_syncing = null;
            if (cb != null) {
              return cb();
            }
          });
          _this.sync_model_base_algo();
          return window.current_syncing.ready();
        };
      })(this));
      this.load_all_from_cloud();
      return window.current_syncing.ready();
    },
    load_all_from_cloud: function() {
      var content, x, _i, _len, _ref, _results;
      log("loads all the data from the cloud locally");
      this.cloudcache = {};
      _ref = window.todo.keys();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        x = _ref[_i];
        content = this.fromCloudStructure(window.todo.get(x));
        if (content.type === this.name) {
          _results.push(this.cloudcache[x] = content);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    get_delta: function() {
      return log("get the delta for ", this.name, " since last synced");
    },
    extended: function() {
      this.sync(this.proxy(this.real_time_sync));
      return this.fetch(this.proxy(this.loadLocal));
    },
    set_objectchanged_callback: function(callback) {
      if ((typeof callback) !== "function") {
        return console.log("Realtime OBJECT_CHANGED_CALLBACK should be function!");
      }
      if (typeof window.realtime_objectchanged_callback === "undefined") {
        return window.realtime_objectchanged_callback = callback;
      } else {
        delete window.realtime_objectchanged_callback;
        return window.realtime_objectchanged_callback = callback;
      }
    },
    clear_objectchanged_callback: function() {
      if (window.realtime_objectchanged_callback !== "undefined") {
        return delete window.realtime_objectchanged_callback;
      }
    }
  };


  /* initialization and model linking code */

  window.initializeModel = function(model) {
    var field;
    log("model initialization", model);
    field = model.createMap({});
    return model.getRoot().set("todo", field);
  };

  window.onFileLoaded = function(doc) {
    var process_event;
    log("file loaded", doc);
    window.doc = doc;
    process_event = function(event) {
      var a, current_event, model, obj;
      log("PROCESS EVENT");
      log(event);
      current_event = "NONE";
      if (event.oldValue != null) {
        obj = JSON.parse(event.oldValue);
      }
      if (event.newValue != null) {
        obj = JSON.parse(event.newValue);
      }
      log("object", obj);
      window.obj = obj;
      model = Nimbus.dictModel[obj.type];
      if (event.oldValue === null) {
        log("add event");
        model.add_from_cloud(obj.id);
        current_event = "CREATE";
      } else if (event.newValue === null) {
        log("delete event");
        window.currently_syncing = true;
        if (model.exists(obj.id)) {
          a = model.find(obj.id);
          a.destroy();
        }
        window.currently_syncing = false;
        current_event = "DELETE";
      } else {
        log("changing the data inside a entry event");
        model.update_to_local(obj);
        current_event = "UPDATE";
      }
      log("EVENT: ", current_event, " OBJ: ", obj);
      if (window.realtime_update_handler != null) {
        return window.realtime_update_handler(current_event, obj, event.isLocal);
      }
    };
    window.todo = doc.getModel().getRoot().get("todo");
    if (window.real_time_callback != null) {
      window.real_time_callback();
    }
    window.todo.addEventListener(gapi.drive.realtime.EventType.VALUE_CHANGED, process_event);
    if (window.realtime_objectchanged_callback !== "undefined") {
      return todo.addEventListener(gapi.drive.realtime.EventType.VALUE_CHANGED, window.realtime_objectchanged_callback);
    }
  };

  window.create_share_client = function() {
    var share_client;
    share_client = new gapi.drive.share.ShareClient(Nimbus.Auth.app_id);
    share_client.setItemIds(c_file.id);
    share_client.showSettingsDialog();
    return window.share_client = share_client;
  };

  window.handleErrors = handleErrors = function(e) {
    if (e.type === gapi.drive.realtime.ErrorType.TOKEN_REFRESH_REQUIRED) {
      return authorizer.authorize();
    } else if (e.type === gapi.drive.realtime.ErrorType.CLIENT_ERROR) {
      return alert("An Error happened: " + e.message);
    } else if (e.type === gapi.drive.realtime.ErrorType.NOT_FOUND) {
      return alert("The file was not found. It does not exist or you do not have read access to the file.");
    }
  };

  window.startRealtime = function(callback) {
    if (callback != null) {
      window.real_time_callback = callback;
    }
    return gapi.load("auth:client,drive-realtime,drive-share", function() {
      log("gapi for everything loaded");
      return Nimbus.Client.GDrive.getMetadataList("mimeType = 'application/vnd.google-apps.drive-sdk." + Nimbus.Auth.app_id + "'", function(data) {
        var c_file, i, index, workspace, x, _ref;
        console.log("drive apps", data);
        window.app_files = data.items;
        i = [];
        workspace = 0;
        _ref = data.items;
        for (index in _ref) {
          x = _ref[index];
          log(x.mimeType);
          if (x.mimeType.indexOf("application/vnd.google-apps.drive-sdk") >= 0) {
            if (localStorage.last_opened_workspace && x.id === localStorage.last_opened_workspace) {
              workspace = index;
            }
            i.push(x);
          }
        }
        log("index", i);
        if (i.length > 0) {
          log("file there");
          c_file = i[workspace];
          window.c_file = c_file;
          return gapi.drive.realtime.load(c_file.id, onFileLoaded, initializeModel, handleErrors);
        } else {
          log("file not there");
          Nimbus.Client.GDrive.insertFile("", Nimbus.Auth.app_name, 'application/vnd.google-apps.drive-sdk', null, function(data) {
            log("finished insertFile", data);
            window.c_file = data;
            window.app_files.push(data);
            return gapi.drive.realtime.load(data.id, onFileLoaded, initializeModel, handleErrors);
          });
          return log("need to create file for app");
        }
      });
    });
  };

  window.load_new_file = function(file_id, callback, exception_handle) {
    if (callback != null) {
      window.real_time_callback = callback;
    }
    return Nimbus.Share.getFile(file_id, function(data) {
      window.c_file = data;
      if (!data.id) {
        return;
      }
      if (exception_handle && exception_handle instanceof Function) {
        return gapi.drive.realtime.load(file_id, onFileLoaded, initializeModel, exception_handle);
      } else {
        return gapi.drive.realtime.load(file_id, onFileLoaded, initializeModel, handleErrors);
      }
    });
  };

}).call(this);
